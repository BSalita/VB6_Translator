VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "RefEmiter"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Option Explicit

' open issues:
' what path should be used to store files
' what file naming conventions should be used?
' when should files be remade, compare dates of tlib to existing .c .h? and major version change to vbt?
' probably should move code to create AddtionalTypeLibs to vbt so other emitters can use results
'   but must create collection external libs for each typelib to output #includes
' should dispinterfaces use Invoke or stdole_Font_SizeGet/Let/Set?
' forward reference problem test files: auto-r1g\TwoWbr.vbp

Implements Emiter

Private Const sizeofSTDMETHOD As Integer = 4

Private indent As String

Sub Emiter_Emiter(group As vbGroup) ' Change this to byval
Dim ProjectCount As Single
Dim p As vbPrj

indent = "  "
Open group.OutputPath & "RefEmitter.lst" For Output As 99
For Each p In group.Projects
    Print #99, "Processing "; p.prjName
    group.AddIn.ProgressBarUpdate ProjectCount / group.Projects.Count * 100
    ProjectCount = ProjectCount + 1
    Dim OutputPath As String
    OutputPath = VBTOutputPath(group, p, "c")
    Print #99, "RefEmiter: OutputPath=" & OutputPath
    Dim fdt As Date

' Output Reference .h files
    CollectReferencedTypeLibs p.VBProject.References
'    For Each TLI In p.Components
'        OutputTLib TLI, OutputPath
'    Next
Print #99, "2"
' Loop in case more TLibs are added within For loop
' This demonstrates that ForEach processing loops according to initial collection count.
' This behavior might have changed in a VS6 update.
' Must use While instead of For in case .Count is incremented within OutputTLib.
    Dim i As Long
    While i < AdditionalTypeLibs.Count
Print #99, "3"
        i = i + 1
        group.AddIn.ProgressBarInit "Reference TypeLib Emitter - Processing " & OutputPath & AdditionalTypeLibs.Item(i).Name & ".c"
        OutputTLib AdditionalTypeLibs.Item(i), OutputPath
    Wend
Print #99, "5"
Next
Close #99
End Sub

Sub OutputTLib(ByVal tli As TypeLibInfo, ByVal OutputPath As String)
' When and where should typelib .c and .h files be generated?
' Need to compare date/times of typelib files with any existing .c and .h
' If .c or .h is missing should both be generated?
Dim fso As New FileSystemObject
Print #99, "OutputTLib: Name="; tli.Name; " GUID="; tli.GUID; " File="; tli.ContainingFile
If fso.FileExists(OutputPath & tli.Name & "_i.c") And fso.FileExists(OutputPath & tli.Name & "_i.h") Then
    Print #99, ".c and .h exist - suppressing file generation"
Else
' Using TypeLib name for include file name - should filename be used instead?
    Open OutputPath & tli.Name & "_i.h" For Output As 1
    Print #1, "/* This file is always generated by Softworks VBT */"
    Print #1,
    Print #1, "/* TypeLib: "; tli.Name; " "; tli.GUID; " "; tli.MajorVersion; "."; tli.MinorVersion; "*/"
    Print #1,
    Print #1, "#ifndef _INC_"; tli.Name
    Print #1, "#define _INC_"; tli.Name
    Print #1,
    Print #1, "#include ""vbtcom.h"""
    FindAdditionalTypeLibs tli
    OutputConstantInfos tli
    OutputTypedefInterfaces tli
    ' fixme: anticipating forward reference problem if union contains undefined types (structs)
    OutputTypeInfoTypeDefs tli
'    OutputUnionInfos tli ' adirec1a\project1.vbp
    OutputInterfaces tli
    OutputDeclarationInfos tli
    Print #1,
    Print #1, "#endif /* _INC_"; tli.Name; " */"
Print #99, "close "; tli.Name & "_i.h"
    Close #1
    Open OutputPath & tli.Name & "_i.c" For Output As 1
    Print #1, "/* This file is always generated by Softworks VBT */"
    Print #1,
    Print #1, "/* TypeLib: "; tli.Name; " "; tli.GUID; " "; tli.MajorVersion; "."; tli.MinorVersion; "*/"
    Print #1,
    Print #1, "#define INCLUDE_INTERFACES"
    Print #1, "#include """; tli.Name; "_i.h"""
    Print #1,
    Print #1, "/* Helper routines */"
    Dim ii As InterfaceInfo
' skip hidden interfaces?
    For Each ii In tli.Interfaces
        OutputInterfaceInfo tli, ii, True
    Next
    Print #1,
    Print #1, "/* End of File */" ' do this for all files
Print #99, "close "; tli.Name & "_i.c"
    Close #1
End If
End Sub

Sub FindAdditionalTypeLibs(ByVal tli As TypeLibInfo)
Print #99, "FindAdditionalTypeLibs: tli.n="; tli.Name; " ti.c="; tli.TypeInfos.Count
Dim ti As TypeInfo
Dim mi As MemberInfo
Dim pi As ParameterInfo
Dim ExternalTypeLibs As New Collection
' skip hidden interfaces?
For Each ti In tli.TypeInfos
    Print #99, "  ti="; ti.Name; " tk="; ti.TypeKind; " tin="; ti.TypeInfoNumber
    If TypeOf ti Is InterfaceInfo Then
        Print #99, "  vtbl="; Not ti.VTableInterface Is Nothing
        If ti.VTableInterface Is Nothing Then
            Print #99, "  No VTableInterface for "; TypeInfoToCType(ti)
        Else
            Set ti = ti.VTableInterface ' changing For Each variable - seems ok
        End If
    End If
    If TypeOf ti Is CoClassInfo Then Set ti = ti.DefaultInterface
    If TypeOf ti Is InterfaceInfo Or TypeOf ti Is RecordInfo Or TypeOf ti Is UnionInfo Then
        Print #99, "  mc="; ti.Members.Count
        For Each mi In ti.Members
            Print #99, "    mi="; mi.Name; " pc="; mi.Parameters.Count; " rt="; Not mi.ReturnType Is Nothing
            On Error GoTo 10
            For Each pi In mi.Parameters
                Print #99, "      pi="; pi.Name; " extern="; pi.VarTypeInfo.IsExternalType
                If pi.VarTypeInfo.IsExternalType Then AddTypeLib pi.VarTypeInfo, ExternalTypeLibs
            Next
            ' assuming that ReturnType could return external interface
            If Not mi.ReturnType Is Nothing Then If mi.ReturnType.IsExternalType Then AddTypeLib mi.ReturnType, ExternalTypeLibs
            If False Then
10              Print #99, "Bad typelib entry: " & tli.Name & "." & ti.Name & "." & mi.Name
                MsgBox "Bad typelib entry: " & tli.Name & "." & ti.Name & "." & mi.Name
                Resume 20
            End If
20
        Next
    End If
Next
Print #99, "FindAdditionalTypeLibs: ec="; ExternalTypeLibs.Count
End Sub

Sub AddTypeLib(ByVal vti As VarTypeInfo, ByVal ExternalTypeLibs As Collection)
Print #99, "AddTypeLib: n="; vti.TypeInfo.Name; " ext.n="; vti.TypeLibInfoExternal.Name; " f="; vti.TypeLibInfoExternal.ContainingFile; " major="; vti.TypeLibInfoExternal.MajorVersion; " minor="; vti.TypeLibInfoExternal.MinorVersion; " ec="; ExternalTypeLibs.Count
Dim etli As TypeLibInfo
On Error Resume Next
Set etli = ExternalTypeLibs.Item(vti.TypeLibInfoExternal.GUID)
On Error GoTo 0
If etli Is Nothing Then
    Print #99, "      adding "; vti.TypeLibInfoExternal.Name; " to eTLs"
    Print #1, "#include """; vti.TypeLibInfoExternal.Name; "_i.h"""
    ExternalTypeLibs.Add vti.TypeLibInfoExternal, vti.TypeLibInfoExternal.GUID
    Set etli = Nothing
    On Error Resume Next
    Set etli = AdditionalTypeLibs.Item(vti.TypeLibInfoExternal.GUID)
    On Error GoTo 0
    If etli Is Nothing Then
        Print #99, "      adding "; vti.TypeLibInfoExternal.Name; " to aTLs"
        AdditionalTypeLibs.Add vti.TypeLibInfoExternal, vti.TypeLibInfoExternal.GUID
    Else
        CheckTypeLibVersion etli, vti.TypeLibInfoExternal, AdditionalTypeLibs
    End If
Else
    CheckTypeLibVersion etli, vti.TypeLibInfoExternal, ExternalTypeLibs
End If
End Sub

' Use newest typelib. Replace older version with newer in TypeLib collection, if needed.
Sub CheckTypeLibVersion(ByVal etli As TypeLibInfo, ByVal tlib As TypeLibInfo, ByVal TypeLibs As Collection)
Print #99, "CheckTypeLibVersion: tlibs.c="; TypeLibs.Count
Print #99, "tlib: n="; tlib.Name; " f="; tlib.ContainingFile; " major="; tlib.MajorVersion; " minor="; tlib.MinorVersion; " guid="; tlib.GUID
Print #99, "etli: n="; etli.Name; " f="; etli.ContainingFile; " major="; etli.MajorVersion; " minor="; etli.MinorVersion; " guid="; etli.GUID
If tlib.MajorVersion > etli.MajorVersion Or (tlib.MajorVersion = etli.MajorVersion And tlib.MinorVersion > etli.MinorVersion) Then
    ' fixme: Use Dictionary object instead. Looping collection to obtain Remove index.
    Dim i As Long
    For i = 1 To TypeLibs.Count
        Print #99, "i="; i; " guid="; TypeLibs.Item(i).GUID
        If tlib.GUID = TypeLibs.Item(i).GUID Then Exit For
    Next
    If i > TypeLibs.Count Then Err.Raise 1
    Print #99, "removing "; TypeLibs.Item(i).ContainingFile; " adding "; tlib.ContainingFile
    TypeLibs.Remove i
    TypeLibs.Add tlib, tlib.GUID
End If
End Sub

Sub OutputInterfaces(ByVal tli As TypeLibInfo)
Print #99, "OutputInterfaces: c="; tli.Interfaces.Count
Dim ii As InterfaceInfo
Dim iiv As InterfaceInfo
Dim tk As TypeKinds
Print #1,
Print #1, "#ifdef INCLUDE_INTERFACES"
' skip hidden interfaces?
For Each ii In tli.Interfaces
    If Left(ii.Name, 2) <> "_" & Chr(1) Then ' don't output hidden interfaces
        tk = ii.TypeKind
        If tk = TKIND_ALIAS Then
            Print #99, "tk is alias"
        Else
            Set iiv = ii
Print #99, "ii="; iiv.Name; " major="; iiv.MajorVersion; " minor="; ; iiv.MinorVersion; " typekind="; tk
            On Error Resume Next
            Set iiv = ii.VTableInterface
            On Error GoTo 0
            Print #1,
            If iiv Is Nothing Then
Print #99, "No vtable interface for "; ii.Name
                Print #1, "/* dispinterface: "; ii.Name; " "; ii.MajorVersion; "."; ii.MinorVersion; " "; ii.GUID; " */"
                Dim mi As MemberInfo
                For Each mi In ii.Members
#If 1 Then
                    Print #1, "/* "; mi.Name; " */"
#Else
                    ' first mi is full version, 2nd mi is vtable version (could be partial)
                    ' output all 3 prototypes
                    OutputMemberInfo tli, ii, mi, mi, INVOKE_PROPERTYGET, False
                    OutputMemberInfo tli, ii, mi, mi, INVOKE_PROPERTYPUT, False
                    OutputMemberInfo tli, ii, mi, mi, INVOKE_PROPERTYPUTREF, False
#End If
                Next
            Else
                OutputDeclareInterface tli, ii, iiv
            End If
        End If ' TypeKind = TKIND_ALIAS
    End If ' _ hidden
Next
Print #1,
Print #1, "#endif /* INCLUDE_INTERFACES */"
End Sub

Sub OutputDeclareInterface(ByVal tli As TypeLibInfo, ByVal ii As InterfaceInfo, ByVal iiv As InterfaceInfo)
Print #99, "OutputDeclareInterface: ii.n="; ii.Name; ii.TypeInfoNumber; " ii.g="; ii.GUID; " iiv.n="; iiv.Name; iiv.TypeInfoNumber; " iiv.g="; iiv.GUID
' fixme: Need to eliminate iiv?
Dim mi As MemberInfo
Dim s As String
On Error Resume Next
Print #99, "am="; Hex(ii.AttributeMask)
Print #99, "iic="; ii.ImpliedInterfaces.Count
Print #99, "rt="; ii.ResolvedType.ElementPointerLevel
Print #99, "rt="; ii.ResolvedType.IsExternalType
Print #99, "rt="; ii.ResolvedType.PointerLevel
Print #99, "am="; Hex(iiv.AttributeMask)
Print #99, "iic="; iiv.ImpliedInterfaces.Count
Print #99, "rt="; iiv.ResolvedType.ElementPointerLevel
Print #99, "rt="; iiv.ResolvedType.IsExternalType
Print #99, "rt="; iiv.ResolvedType.PointerLevel
On Error GoTo 0
Print #1,
Print #1, "/* Interface: "; TypeInfoToCType(iiv); " "; iiv.MajorVersion; "."; iiv.MinorVersion; " "; iiv.GUID; " */"
Print #1,
Print #1, "#undef INTERFACE"
Print #1, "#define INTERFACE "; TypeInfoToCType(iiv)
Print #1,
If ii.ImpliedInterfaces.Count = 0 Then
    Print #1, "DECLARE_INTERFACE( "; TypeInfoToCType(iiv); " )"
    Print #1, "{"
    Print #1, indent; "INTERFACE_PROLOGUE( "; TypeInfoToCType(iiv); " )"
Else
    Print #1, "DECLARE_INTERFACE_( "; TypeInfoToCType(iiv); ", "; CInterfaceType(ii); " )"
    Print #1, "{"
    Print #1, indent; "INTERFACE_PROLOGUE_( "; TypeInfoToCType(iiv); ", "; CInterfaceType(ii); " )"
End If
Dim cVTable As New Collection
Dim maxoffset As Integer
maxoffset = 0
For Each mi In iiv.Members
    If mi.VTableOffset = -1 Then
        Print #99, "Invalid VTableOffset"
        Err.Raise 1 ' Invalid VTableOffset
    End If
Print #99, "mi="; mi.Name; " memid="; Hex(mi.MemberId); " vto="; Hex(mi.VTableOffset); " dk="; mi.DescKind; " ik="; mi.InvokeKind; " pc="; mi.Parameters.Count
    ' skip default members
    On Error Resume Next ' Reject dups - as in VB6.OLB
    cVTable.Add mi, Right("000" & Hex(mi.VTableOffset), 4)
    On Error GoTo 0
    If mi.VTableOffset > maxoffset Then maxoffset = mi.VTableOffset
Next
Dim currentoff As Integer
For currentoff = 0 To maxoffset Step sizeofSTDMETHOD
    Set mi = Nothing
    On Error Resume Next
    Set mi = cVTable.Item(Right("000" & Hex(currentoff), 4))
    On Error GoTo 0
    If mi Is Nothing Then
        Print #1, indent; "STDMETHODEX( Missing"; CStr(currentoff / sizeofSTDMETHOD); ", ( THIS ) ) /* "; Hex(currentoff); " */"
    Else
Print #99, "VT mi="; mi.Name; " memid="; Hex(mi.MemberId); " vto="; Hex(mi.VTableOffset); " dk="; mi.DescKind; " ik="; mi.InvokeKind; " pc="; mi.Parameters.Count
        s = ""
        Dim i As Integer
        Dim pi As ParameterInfo
        Dim retval As ParameterInfo
        Set retval = Nothing
        On Error GoTo 10
        For Each pi In mi.Parameters
            i = i + 1
Print #99, "pi="; pi.Name; i
            s = s & "," & VarTypeInfoToCType(pi.VarTypeInfo) & " " & IIf(pi.Flags And PARAMFLAG_FRETVAL, "retval", "_p_" & pi.Name)
            ' need to check for last param also?
            ' note: Additem in vb6.idl doesn't contain param names
            If pi.Flags And PARAMFLAG_FRETVAL Then
                If Not retval Is Nothing Then Err.Raise 1 ' TypeLib error - multiple PARAMFLAG_FRETVAL
                Set retval = pi
            End If
            If pi.Name = "" Then
'                If i = mi.Parameters.Count And (mi.InvokeKind = INVOKE_PROPERTYPUT Or mi.InvokeKind = INVOKE_PROPERTYPUTREF) Then
                If i = mi.Parameters.Count And (mi.InvokeKind And (INVOKE_PROPERTYPUT Or INVOKE_PROPERTYPUTREF)) Then
                    s = s & "putval"
                Else
                    s = s & "arg" & CStr(i)
                End If
            End If
        Next
        s = MINameVTable(mi) & ", ( THIS" & IIf(mi.Parameters.Count = 0, " ", "_ ") & Mid(s, 2) & ") ) /* " & ProcNameIK(mi.Name, mi.InvokeKind) & " */"
        If mi.InvokeKind = INVOKE_PROPERTYGET And retval Is Nothing Then
            s = "_(" & VarTypeInfoToCType(mi.ReturnType, 1) & ", " & s
            Print #99, "warning: propget method missing retval: "; iiv.Name; "."; mi.Name
        Else
            s = "(" & s
        End If
        s = indent & "STDMETHODEX" & s
        Print #1, s
        Print #99, s
        If False Then
10          Print #99, "Bad typelib entry: " & tli.Name & "." & iiv.Name & "." & mi.Name
'            MsgBox "Bad typelib entry: " & tli.Name & "." & iiv.Name & "." & mi.Name
            Resume 20
        End If
20      On Error GoTo 0
    End If
Next
If ii.ImpliedInterfaces.Count = 0 Then
    Print #1, indent; "INTERFACE_EPILOGUE( "; TypeInfoToCType(iiv); " )"
Else
    Print #1, indent; "INTERFACE_EPILOGUE_( "; TypeInfoToCType(iiv); ", "; CInterfaceType(ii); " )"
End If
Print #1, "};"
' need to put this in a sub - similar to what is used below and in cemiter
For Each mi In cVTable
Print #99, "ref: ii="; ii.Name; " iiv="; iiv.Name; " mi="; mi.Name
    If mi.AttributeMask And 1 Then
        Print #1, "/* "; mi.Name; " */" ' Hidden member
    Else
        OutputMemberInfo tli, iiv, mi, mi.InvokeKind, False
    End If
Next
End Sub

Sub OutputConstantInfos(ByVal tli As TypeLibInfo)
Dim ci As ConstantInfo
Dim mi As MemberInfo
Print #99, "OutputConstantInfos: c="; tli.Constants.Count
Print #1,
For Each ci In tli.Constants
Print #99, "  ci.name="; ci.Name
    For Each mi In ci.Members
Print #99, "    mi.name="; mi.Name
        Print #1, "#define "; TypeInfoToCType(ci); "_"; mi.Name; " ("; ValueToC(VarTypeInfoToVarType(mi.ReturnType), mi.Value); ")"
    Next
    ' fixme: is LONG the correct data type?
    Print #1, "typedef LONG "; TypeInfoToCType(ci); ";"
Next
End Sub

Sub OutputTypedefInterfaces(ByVal tli As TypeLibInfo)
Print #99, "OutputTypedefInterfaces: tli="; tli.Name; " c="; tli.Interfaces.Count
Print #1,
' skip hidden interfaces?
Dim ii As InterfaceInfo
For Each ii In tli.Interfaces
Print #99, "  ii="; ii.Name; " tk="; ii.TypeKind
    If Left(ii.Name, 2) <> "_" & Chr(1) Then ' don't output hidden interfaces
        Select Case ii.TypeKind
        Case TKIND_ALIAS
            ' fixme: use TypeInfo instead inf dt*Info
            'Print #1, "typedef struct _" & VarTypeInfoToCType(ResolveTypeKind(ii), 1); " "; VarTypeInfoToCType(ResolveTypeKind(ii), 1); ";"
        Case TKIND_DISPATCH
            Dim iiv As InterfaceInfo
            On Error Resume Next
            Set iiv = ii.VTableInterface
            On Error GoTo 0
            If iiv Is Nothing Then
                Print #1, "typedef interface IDispatch "; TypeInfoToCType(ii); ";"
                Print #1, TypeInfoToCType(ii); " **"; TypeInfoToCType(ii); "SA(SAFEARRAY *sa,int nDims,...);"
            Else
                Print #1, "typedef interface "; TypeInfoToCType(iiv); " "; TypeInfoToCType(iiv); ";"
                Print #1, TypeInfoToCType(iiv); " **"; TypeInfoToCType(iiv); "SA(SAFEARRAY *sa,int nDims,...);"
            End If
        Case TKIND_INTERFACE
            On Error Resume Next
            Set iiv = ii.VTableInterface
            On Error GoTo 0
            If iiv Is Nothing Then
                Print #99, "Expecting VTable for interface: "; TypeInfoToCType(ii)
                Err.Raise 1
            End If
            Print #1, "typedef interface "; TypeInfoToCType(iiv); " "; TypeInfoToCType(iiv); ";"
            Print #1, TypeInfoToCType(iiv); " **"; TypeInfoToCType(iiv); "SA(SAFEARRAY *sa,int nDims,...);"
        Case Else
            Err.Raise 1
        End Select
    End If ' _ (hidden)
Next
End Sub

Sub AddStruct(ByVal structs As Collection, ByVal ti As TypeInfo, ByVal counter As Long)
' RecordInfo and UnionInfo GUIDs are zeros, so musn't use to compare.
Dim foundti As TypeInfo
On Error Resume Next
Set foundti = structs.Item(ti.Name)
On Error GoTo 0
Print #99, String(counter + 1, " "); "AddStruct: ti="; ti.Parent; "_"; ti.Name; " fnd="; Not foundti Is Nothing; " tc="; ti.Members.Count; " ti.guid="; ti.GUID; " sc="; structs.Count; " rc="; ti.Parent.Records.Count; " uc="; ti.Parent.Unions.Count; " counter="; counter
' fixme: Is this check for infinite recursion always valid?
Dim mi As MemberInfo
If foundti Is Nothing Then
    If counter > ti.Parent.Records.Count + ti.Parent.Unions.Count Then
        MsgBox "Unable to resolve forward referencing problem for typelib: " & TypeInfoToCType(ti) & ". Manual editing of header file required."
'        Err.Raise 1
    Else
        counter = counter + 1
        For Each mi In ti.Members
            Print #99, String(counter, " "); "mi="; mi.Name; " rt="; Not mi.ReturnType Is Nothing
            Print #99, String(counter, " "); "vt="; mi.ReturnType.VarType
            If mi.ReturnType.VarType = 0 Then
                Print #99, String(counter, " "); "tk="; mi.ReturnType.TypeInfo.TypeKind; " extern="; mi.ReturnType.IsExternalType
                Print #99, String(counter, " "); "g="; ti.Parent.GUID; " rt.g="; mi.ReturnType.TypeInfo.Parent.GUID
                ' fixme: Why isn't IsExternalType flag set? So comparing TLib GUIDs instead. Must be because some TLibs have TypeInfos that don't need external pointers.
                If ti.Parent.GUID = mi.ReturnType.TypeInfo.Parent.GUID Then ' This TLib?
                    Print #99, "ext="; mi.ReturnType.IsExternalType
                    If Not mi.ReturnType.IsExternalType Then ' internal to this TLib?
                        Print #99, "ri="; TypeOf mi.ReturnType.TypeInfo Is RecordInfo; " ui="; TypeOf mi.ReturnType.TypeInfo Is UnionInfo
                        If TypeOf mi.ReturnType.TypeInfo Is RecordInfo Or TypeOf mi.ReturnType.TypeInfo Is UnionInfo Then ' only structs or unions
                            Print #99, "rt="; mi.ReturnType.TypeInfo.Name; " ti="; ti.Name
                            If mi.ReturnType.TypeInfo.Name <> ti.Name Then ' ignore self-referencing members
                                If mi.ReturnType.PointerLevel = 0 Then
                                    Dim newti As TypeInfo
                                    Set newti = mi.ReturnType.TypeInfo
                                    Print #99, String(counter, " "); "new ti="; newti.Name
                                    Set foundti = Nothing
                                    On Error Resume Next
                                    Set foundti = structs.Item(newti.Name)
                                    On Error GoTo 0
                                    If foundti Is Nothing Then
                                        Print #99, String(counter, " "); "not found"
                                        ' fixme: doesn't handle self-reference within ti
                                        AddStruct structs, newti, counter
                                    Else
            '                            If Not foundti Is newti Then Err.Raise 1
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        Next
    End If
    ' add this struct last, after any dependant definitions
    On Error Resume Next
    structs.Add ti, ti.Name
    On Error GoTo 0
End If
Print #99, String(counter, " "); "ti="; ti.Name; " c="; structs.Count; " counter="; counter
End Sub

' Output typedefs to satisfy forward references
Sub OutputTypeInfoTypeDefs(ByVal tli As TypeLibInfo)
Dim structs As New Collection
Print #99, "OutputTypeInfoTypeDefs: tli="; tli.Name; " rc="; tli.Records.Count; " uc="; tli.Unions.Count
Dim ti As TypeInfo
For Each ti In tli.Records
    AddStruct structs, ti, 0
Next
For Each ti In tli.Unions
    AddStruct structs, ti, 0
Next
Print #99, "OutputTypeInfoTypeDefs: c="; structs.Count
'Print #1,
'For Each ri In structs
'    Print #99, "typedef struct _"; TypeInfoToCType(ri); " "; TypeInfoToCType(ri); ";"
'    Print #1, "typedef struct _";  TypeInfoToCType(ri); " "; TypeInfoToCType(ri); ";"
'Next
OutputTypeInfoStructs structs
End Sub

Sub OutputTypeInfoStructs(ByVal structs As Collection)
Dim ti As TypeInfo
Dim mi As MemberInfo
Print #99, "OutputTypeInfoStructs: c="; structs.Count
If structs.Count > 0 Then
    Print #1,
    ' output typedef for forward references. only required for members which are self-referencing. easier to do for all, better style anyway.
    For Each ti In structs
        Print #99, "  ti="; ti.Name; " tk="; ti.TypeKind
        If TypeOf ti Is RecordInfo Then
            Print #1, "typedef struct _";
        ElseIf TypeOf ti Is UnionInfo Then
            Print #1, "typedef union _";
        Else
            Err.Raise 1
        End If
        Print #1, TypeInfoToCType(ti); " "; TypeInfoToCType(ti); ";"
    Next
    For Each ti In structs
        Print #99, "  ti="; ti.Name; " tk="; ti.TypeKind
        Print #1,
        If TypeOf ti Is RecordInfo Then
            Print #1, "typedef struct _"; TypeInfoToCType(ti)
        ElseIf TypeOf ti Is UnionInfo Then
            Print #1, "typedef union _"; TypeInfoToCType(ti)
        Else
            Err.Raise 1
        End If
        Print #1, "{"
        For Each mi In ti.Members
            Print #99, "    mi="; mi.Name
    ' Needs to be made into a subroutine - pass memberinfo, not vartype
            If mi.ReturnType.VarType And VT_VECTOR Then
                Dim s As String
                s = ""
                Print #1, indent; "SAFEARRAY *_v_"; mi.Name; ";";
                Dim bounds() As Long
                s = s & " /* "
                Dim i As Integer
                For i = 1 To mi.ReturnType.ArrayBounds(bounds())
                    s = s & "[" & bounds(i, 2) - bounds(i, 1) & "]"
                Next
                s = s & " */"
                Print #1, s
            ElseIf mi.ReturnType.VarType And VT_ARRAY Then
                Print #1, indent; "SAFEARRAY *_v_"; mi.Name; "; /* [] */"
            Else
                Print #1, indent; VarTypeInfoToCType(mi.ReturnType); " _v_"; mi.Name; ";"
            End If
        Next
        Print #1, "} "; TypeInfoToCType(ti); ";"
        Print #1, TypeInfoToCType(ti); " *"; TypeInfoToCType(ti); "SA(SAFEARRAY *sa,int nDims,...);"
    Next
End If
End Sub

Sub OutputDeclarationInfos(ByVal tli As TypeLibInfo)
Dim di As DeclarationInfo
Dim mi As MemberInfo
Dim pi As ParameterInfo
Dim s As String
Print #99, "OutputDeclarationInfos: c="; tli.Declarations.Count
For Each di In tli.Declarations
Print #99, "  di.name="; di.Name
    Print #1,
    Print #1, "/* Declaration: "; di.Name; " "; di.MajorVersion; "."; di.MinorVersion; " */"
    For Each mi In di.Members
Print #99, "    mi="; mi.Name; " memberid="; Hex(mi.MemberId); " vtableoffset="; Hex(mi.VTableOffset); " p.count="; mi.Parameters.Count
        s = ""
        For Each pi In mi.Parameters
Print #99, "      pi="; pi.Name
            s = s & "," & VarTypeInfoToCType(pi.VarTypeInfo) & " _p_" & pi.Name
        Next
        If mi.InvokeKind And (INVOKE_PROPERTYPUT Or INVOKE_PROPERTYPUTREF) Then
' to deref or not to deref? "Time = 0" suggests not to otherwise requires changes to getreturntype and elsewhere.
'            s = s & "," & VarTypeInfoToCType(mi.ReturnType, 1) & " putval"
            s = s & "," & VarTypeInfoToCType(mi.ReturnType) & " putval"
            Print #1, "void";
        Else
            Print #1, VarTypeInfoToCType(mi.ReturnType);
        End If
        Print #1, " WINAPI "; TypeInfoToCType(di); "_"; ProcNameIK(mi.Name, mi.InvokeKind); "("; IIf(s = "", "void", Mid(s, 2)); ");"
    Next
Next
End Sub

