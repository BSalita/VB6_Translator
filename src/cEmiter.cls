VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "cEmiter"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_Ext_KEY = "SavedWithClassBuilder6" ,"Yes"
Attribute VB_Ext_KEY = "Top_Level" ,"Yes"
Option Explicit

Implements Emiter

Private m_Group As vbGroup
Private TotalLines As Single
Private LineCount As Single

Sub Emiter_Emiter(group As vbGroup) ' Change this to byval
Dim p As vbPrj
Dim m As vbModule
Dim d As vbDeclare
Dim proc As procTable
Dim param As paramTable
Dim first_time As Boolean
Dim i As Integer
Dim s As String

indent = IndentString
Set m_Group = group
Open group.OutputPath & "cEmitter.lst" For Output As 99
For Each p In group.Projects
    For Each m In p.prjModules
        For Each proc In m.procs
            TotalLines = TotalLines + proc.procStatements.Count
        Next
        For Each proc In m.Events
            TotalLines = TotalLines + proc.procStatements.Count
        Next
    Next
Next
TotalLines = TotalLines / 100
For Each p In group.Projects
    Dim OutputPath As String
    OutputPath = VBTOutputPath(group, p, "c")
    Print #99, "before pbi"
    group.AddIn.ProgressBarInit "C Generator: Creating " & OutputPath & p.prjName & ".h"
    Print #99, "after pbi"
' Output Project .h file
    Open OutputPath & p.prjName & ".h" For Output As 1
    Print #1, "/* This file is always generated by Softworks VBT */"
    Print #1,
    Print #1, "#include ""vbtcom.h"""
'    Print #1, "#include ""stdole_i.h"""
    On Error GoTo bad_exe
    If p.VBProject Is Nothing Then
bad_exe:
        Print #99, "Error is due to bad vbt.exe process. End vbt.exe process or reboot."
        MsgBox "Error is due to bad vbt.exe process. End vbt.exe process or reboot."
        On Error GoTo 0
        Err.Raise 1 ' Bad vbt.exe
    End If
    On Error GoTo 0
    Print #99, "1"
    Print #99, Not p.VBProject Is Nothing
    Print #99, "2"
    Print #99, Not p.VBProject.References Is Nothing
    Print #99, p.VBProject.References.Count
    CollectReferencedTypeLibs p.VBProject.References
    ' Libraries have been validated in vbt
    Dim tlib As TypeLibInfo
    For Each tlib In AdditionalTypeLibs
        Print #1, "#include """; tlib.Name; "_i.h"""
    Next
    Print #1,
    Print #1, "#include ""vbt.h"""
    Print #1,
    For Each m In p.prjModulesOrdered
        If m.Component.Type <> vbext_ct_StdModule Then
            ' fixme: use TypeInfoToCType (which uses lib_interface)?
            Print #1, "typedef interface __i_"; m.Name; " _i_"; m.Name; ";"
            ' event interface might not exist
            If m.EventName <> "" Then Print #1, "typedef interface __i_"; m.EventName; " _i_"; m.EventName; ";"
        End If
#If 0 Then ' obsoleted by use of prjModulesOrdered #include?
        ' forward reference problem. some modules may use Public Type from other modules. Can't insure headers are in correct order so use explicit typedef.
        Dim t As vbType
        For Each t In m.types
            Print #99, "t.at="; Hex(t.typeAttributes)
            ' fixme: Should use vbVariable. There's no way to know which UDTs are public. Must use vbVariable instead.
            ' fixme: doesn't this have to be done for unions too?
            Print #99, "typedef struct __t_" & m.Name & "_" & t.TypeName & " _t_" & m.Name & "_" & t.TypeName & ";"
            Print #1, "typedef struct __t_" & m.Name & "_" & t.TypeName & " _t_" & m.Name & "_" & t.TypeName & ";"
        Next
#End If
    Next
    For Each m In p.prjModulesOrdered
        Print #1, "#include """; m.Name; ".h"""
    Next
    Dim token As vbToken
    ' Output protos for New classes
    If p.NewObjects.Count > 0 Then Print #1,
    For Each token In p.NewObjects
        Print #99, "New type="; token.tokVariable.VarType.dtType
        Select Case token.tokVariable.VarType.dtType
            Case tokProjectClass, tokFormClass
                Print #1, "_i_" & token.tokVariable.VarType.dtClass.Name & " *_i_" & token.tokVariable.VarType.dtClass.Name & "_New;"
            Case tokReferenceClass
                Print #1, TypeInfoToCType(token.tokVariable.VarType.dtInterfaceInfo) & " *" & TypeInfoToCType(token.tokVariable.VarType.dtInterfaceInfo) & "_New;"
            Case tokIDispatchInterface
                Print #1, "IDispatch *_i_StdOle_IDispatch_New;"
            Case Else
                Err.Raise 1
        End Select
    Next
    ' Output protos for object coersion (QueryInterface)
    If p.CoerceObjects.Count > 0 Then Print #1,
    For Each token In p.CoerceObjects
        Print #99, "type="; token.tokType
        Select Case token.tokType
            Case tokQI_Module ' Class
                Print #1, "_i_"; token.tokModule.Name; " *_i_"; token.tokModule.Name; "QI(void *This);"
                ' fixme: only output Event QI if RaiseEvent is used
                ' fixme: should be outputing by Interface, not by class
                If token.tokModule.EventName <> "" Then Print #1, "_i_"; token.tokModule.EventName; " *_i_"; token.tokModule.EventName; "QI(void *This);"
                Print #1, "_i_"; token.tokModule.Name; " **_i_"; token.tokModule.Name; "QIRef(void *This);"
                If token.tokModule.EventName <> "" Then Print #1, "_i_"; token.tokModule.EventName; " **_i_"; token.tokModule.EventName; "QIRef(void *This);"
            Case tokQI_TLibInterface
                ' Using IDispatch for interface name instead of _stdole_IDispatch avoids typedef mismatches
                If token.tokInterfaceInfo.Parent.Name = "stdole" And (token.tokInterfaceInfo.Name = "IUnknown" Or token.tokInterfaceInfo.Name = "IDispatch") Then
                    Print #1, token.tokInterfaceInfo.Name; " *"; TypeInfoToCType(token.tokInterfaceInfo); "QI(void *This);"
                Else
                    Print #1, TypeInfoToCType(token.tokInterfaceInfo); " *"; TypeInfoToCType(token.tokInterfaceInfo); "QI(void *This);"
                End If
                If token.tokInterfaceInfo.Parent.Name = "stdole" And (token.tokInterfaceInfo.Name = "IUnknown" Or token.tokInterfaceInfo.Name = "IDispatch") Then
                    Print #1, token.tokInterfaceInfo.Name; " **"; TypeInfoToCType(token.tokInterfaceInfo); "QIRef(void *This);"
                Else
                    Print #1, TypeInfoToCType(token.tokInterfaceInfo); " **"; TypeInfoToCType(token.tokInterfaceInfo); "QIRef(void *This);"
                End If
            Case Else
                Err.Raise 1
        End Select
    Next
    Dim tliref As vbtTLIRef
    For Each tliref In p.prjTLIRefs
        ' fixme: This code is similar to declaration output routine in refemitter. Should be combined and moved to vbtcsubs.cls
        Set tlib = tliref.RefTLib
        Print #1,
        Print #1, "/* "; tlib.Name; "_i.h */"
        Dim declMember As vbtTLIDeclarationMember
        Dim mi As MemberInfo
        Dim pi As ParameterInfo
        For Each declMember In tliref.RefDeclarationMembers
            Set mi = declMember.MemberInfo
            Print #99, "dm: di="; TypeInfoToCType(declMember.DeclarationInfo); " mi.name="; mi.Name; " mi.ik="; mi.InvokeKind; " mi.p.c="; mi.Parameters.Count; " rt="; Not mi.ReturnType Is Nothing
            s = ""
            For Each pi In mi.Parameters
                Print #99, "pi.name="; pi.Name; " pi.vti="; pi.VarTypeInfo Is Nothing; " pi.flags="; pi.Flags
                s = s & "," & VarTypeInfoToCType(pi.VarTypeInfo) & " _p_" & pi.Name
            Next
            If mi.ReturnType Is Nothing Then
                Print #1, "void WINAPI ";
            ElseIf mi.InvokeKind And (INVOKE_PROPERTYPUT Or INVOKE_PROPERTYPUTREF) Then
' don't understand why, _m_VBA_DateTime__B_var_TimeLet is a propput that has a ReturnType. Shouldn't this be impossible?
' to deref or not to deref? If changing to deref, requires change to refemitter and getreturntype and others.
                s = s & "," & VarTypeInfoToCType(mi.ReturnType) & " _p_putval"
                Print #1, "void ";
            Else
                Print #1, VarTypeInfoToCType(mi.ReturnType);
            End If
            ' changed VT_UNKNOWN to mi.InvokeKind for Now() (uses INVOKE_PROPERTYGET)
            Print #1, " WINAPI "; TypeInfoToCType(declMember.DeclarationInfo) & "_" & ProcNameIK(mi.Name, mi.InvokeKind); "("; IIf(s = "", "void", Mid(s, 2)); ");"
        Next
        Dim ifaceMember As vbtTLIInterfaceMember
        For Each ifaceMember In tliref.RefInterfaceMembers
            ' must pass VTableInterface MemberInfo
            ' GetMember doesn't create MemberInfo with correct InvokeKind, so use non-vtable version
            Print #99, "ii="; ifaceMember.InterfaceInfo.Name; " mi.name="; ifaceMember.MemberInfo.Name; " ik="; ifaceMember.MemberInfo.InvokeKind; " pc="; ifaceMember.MemberInfo.Parameters.Count; " ik="; ifaceMember.InvokeKind
#If 0 Then
            ' search for name and ik
Print #99, "1"
            On Error Resume Next
            Dim iiv As InterfaceInfo
Print #99, "2"
            Set iiv = Nothing
            Set iiv = ifaceMember.InterfaceInfo.VTableInterface
            On Error GoTo 0
Print #99, "3"
            If iiv Is Nothing Then
Print #99, "4"
                Set mi = ifaceMember.MemberInfo
            Else
Print #99, "5"
                For Each mi In iiv.Members
Print #99, "n="; ifaceMember.MemberInfo.Name; " mi.n="; mi.Name; " mi.ik="; mi.InvokeKind; " ik="; ifaceMember.InvokeKind
                    If mi.Name = ifaceMember.MemberInfo.Name And mi.InvokeKind = ifaceMember.MemberInfo.InvokeKind Then Exit For
                Next
Print #99, "6"
                If mi Is Nothing Then
                    For Each iiv In iiv.ImpliedInterfaces
                        For Each mi In iiv.Members
Print #99, "impl.n="; iiv.Name; " ifm.n="; ifaceMember.MemberInfo.Name; " mi.n="; mi.Name; " mi.ik="; mi.InvokeKind; " ik="; ifaceMember.InvokeKind
                            If mi.Name = ifaceMember.MemberInfo.Name And mi.InvokeKind = ifaceMember.MemberInfo.InvokeKind Then Exit For
                        Next
                    Next
                End If
Print #99, "8"
                If mi Is Nothing Then
                    For Each mi In ifaceMember.InterfaceInfo.Members
Print #99, "ii.n="; ifaceMember.MemberInfo.Name; " mi.n="; mi.Name; " mi.ik="; mi.InvokeKind; " ik="; ifaceMember.InvokeKind
                        If mi.Name = ifaceMember.MemberInfo.Name And mi.InvokeKind = ifaceMember.MemberInfo.InvokeKind Then Exit For
                    Next
                    If mi Is Nothing Then Set mi = ifaceMember.MemberInfo
                End If
Print #99, "9"
            End If
' Must use mi (VTable version) for VB_VBGlobal_LoadResData (MCI.vbp)
' fixme: eliminate mi (VTable version)?
Print #99, "10"
            OutputMemberInfo tlib, ifaceMember.InterfaceInfo, ifaceMember.MemberInfo, ifaceMember.InvokeKind, False
#Else
Print #99, "10"
            OutputMemberInfo tlib, ifaceMember.InterfaceInfo, ifaceMember.MemberInfo, ifaceMember.MemberInfo.InvokeKind, False
#End If
        Next
' fixme: there's a more direct way of finding appobject - can't recall now
        Dim CoClassInfo As CoClassInfo
        For Each CoClassInfo In tlib.CoClasses
            If CoClassInfo.AttributeMask And TYPEFLAG_FAPPOBJECT Then
                Print #1, TypeInfoToCType(CoClassInfo); " *"; TypeInfoToCType(CoClassInfo); "_AppObject;"
            End If
        Next
    Next
Print #99, "close 1"
    Close #1

' Output Project .c file
    group.AddIn.ProgressBarInit "C Generator: Creating " & OutputPath & p.prjName & ".c"
    Open OutputPath & p.prjName & ".c" For Output As 1
    Print #1, "/* This file is always generated by Softworks VBT */"
    Print #1,
'    Print #1, "#include ""vbtcom.h"""
'    Print #1, "#include ""stdole_i.h"""
'    For Each ref In p.VBProject.References
'Print #99, "Processing ref="; ref.Name; " path="; ref.FullPath; " guid="; ref.GUID; " broken="; ref.IsBroken; " major="; ref.Major; " minor="; ref.Minor
'        Set TLI = TypeLibInfoFromFile(ref.FullPath)
'        Print #1, "#include """; ref.Name; "_i.c"""
'        Set TLI = Nothing
'    Next
'    Print #1, "#include ""vba.c"""
    Print #1, "#include """; p.prjName; ".h"""
'    For Each m In p.prjModulesOrdered
'        If m.component.type = vbext_ct_ClassModule Then ' no use select
'            Print #1, "#include """; m.Name; ".h"""
'        End If
'    Next
'    Print #1,
    If Not p.TypeLib Is Nothing Then Print #1, define_guid("LIBID", p.TypeLib.Name, p.TypeLib.GUID); " /* " & p.TypeLib.MajorVersion & "." & p.TypeLib.MinorVersion & " */"
    Print #1,
' change to class count!!!
    Print #1, "static const ClassTable * const g_ClassTable[ " & p.prjModules.Count + 1 & " ] ="
    Print #1, "{"
    For Each m In p.prjModules
        Select Case m.Component.Type
            Case vbext_ct_StdModule, vbext_ct_RelatedDocument
            Case Else
                Print #1, indent; "&" & m.Name; "_ClassTable,"
        End Select
    Next
    Print #1, indent; "NULL"
    Print #1, "};"
    Print #1,
' change to class count!!!
    Print #1, "static UINT g_ClassCount = " & p.prjModules.Count & ";"
    Print #1,
    Print #1, "static const ApplicationData g_AppData ="
    Print #1, "{"
    Print #1, indent; "L"""; p.prjName; """, /* AppName */"
    Print #1, "};"
    Print #1,
    Print #1, "ProjectTable g_ProjectTable ="
    Print #1, "{"
    If p.TypeLib Is Nothing Then
        Print #1, indent; "NULL, /* TypeLib.Name */"
        Print #1, indent; "NULL, /* TypeLib.GUID */"
        Print #1, indent; "NULL, /* TypeLib.ContainingFile */"
        Print #1, indent; "0, 0, /* TypeLib.MajorVersion . TypeLib.MinorVersion */"
    Else
        Print #1, indent; "L"""; p.TypeLib.Name; """, /* TypeLib.Name */"
        Print #1, indent; "&LIBID_"; p.TypeLib.Name; ", /* TypeLib.GUID */"
        Print #1, indent; "L"""; p.TypeLib.Name; ".tlb"", /* TypeLib.ContainingFile */"
        Print #1, indent; p.TypeLib.MajorVersion; ","; p.TypeLib.MinorVersion; ", /* TypeLib.MajorVersion . TypeLib.MinorVersion */"
    End If
    Print #1, indent; "&g_ClassCount, /* ClassCount */"
    Print #1, indent; "g_ClassTable, /* ClassTabs */"
    Print #1, indent; "&g_AppData, /* AppData */"
    first_time = True
Print #99, "StartUpObject="; VarType(p.VBProject.VBComponents.StartUpObject)
    If VarType(p.VBProject.VBComponents.StartUpObject) = vbObject Then
' if StartUpObject is vbObject but not a form, then might have to loop through modules to identify ComponentType
        Print #1, indent; "NULL /* "; p.VBProject.VBComponents.StartUpObject.Name; " */ /* Startup Object */"
    Else
Print #99, "suo="; p.VBProject.VBComponents.StartUpObject
Print #99, "modules="; p.prjModules.Count
        Select Case p.VBProject.VBComponents.StartUpObject
            Case vbext_psm_StandAlone
                For Each m In p.prjModules
Print #99, "m="; m.Name; " ct="; m.Component.Type
                    If m.Component.Type = vbext_ct_StdModule Then
                        Set proc = Nothing
                        On Error Resume Next
                        Set proc = m.procs.Item(SymIK("main", INVOKE_FUNC))
Print #99, "procF="; proc Is Nothing
                        If proc Is Nothing Then Set proc = m.procs.Item(SymIK("main", INVOKE_FUNC Or INVOKE_PROPERTYGET))
Print #99, "procFG="; proc Is Nothing
                        On Error GoTo 0
                        If Not proc Is Nothing Then
                            If Not first_time Then Err.Raise 1 ' Multiple Main declared
                            first_time = False
                            Print #1, indent; m.Name; "_"; ProcNameIK(proc.procname, proc.InvokeKind); " /* Startup Object */"
                        End If
                    End If
                Next
                If first_time Then Err.Raise 1 ' Main not defined
            Case vbext_psm_OleServer
                Print #1, indent; "NULL /* Startup Object */"
            Case Else
                Print #99, "CEmitter: Unknown StartUpObject:" & p.VBProject.VBComponents.StartUpObject
                MsgBox "CEmitter: Unknown StartUpObject:" & p.VBProject.VBComponents.StartUpObject
                Err.Raise 1 ' Unknown StartUpObject
        End Select
    End If
    Print #1, "};"
    Close #1

    For Each m In p.prjModules
Print #99, "mod="; m.Name; " ct="; m.Component.Type
        Select Case m.Component.Type
        Case vbext_ct_RelatedDocument
            Print #99, "No code generated for module "; m.Name
        Case vbext_ct_StdModule
' Output Module .h file
            group.AddIn.ProgressBarInit "C Generator: Creating " & OutputPath & m.Name & ".h"
            Open OutputPath & m.Name & ".h" For Output As 1
            Print #1, "/* This file is always generated by Softworks VBT */"
Print #99, "in mod .h 1"
            EmitConstEnumType m, PROC_ATTR_PUBLIC
Print #99, "in mod .h 2"
            Print #1,
            For Each proc In m.procs
                Print #1, cTypeName(proc.procFunctionResultType); " STDMETHODCALLTYPE "; m.Name; "_"; ProcNameIK(proc.procname, proc.InvokeKind); "( ";
                first_time = True
                For Each param In proc.procParams
                    If first_time Then first_time = False Else Print #1, ", ";
                    Print #1, cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                Next
                If first_time Then Print #1, "void";
                Print #1, " );"
            Next
            Close #1
' Output Module .c file
            group.AddIn.ProgressBarInit "C Generator: Creating " & OutputPath & m.Name & ".c"
            Open OutputPath & m.Name & ".c" For Output As 1
            Print #1, "/* This file is always generated by Softworks VBT */"
            Print #1,
            Print #1, "#include """; p.prjName; ".h"""
            EmitConstEnumType m, PROC_ATTR_PRIVATE
Print #99, "m="; m.Name
            OutputMethods m, m.procs, m.Name
Print #99, "close1"
            Close #1
        Case Else
' Output Class .h file
            group.AddIn.ProgressBarInit "C Generator: Creating " & OutputPath & m.Name & ".h"
            Open OutputPath & m.Name & ".h" For Output As 1
            Print #1, "/* This file is always generated by Softworks VBT */"
'            If m.ModuleVars.Count > 0 Then err.raise 1 ' internal error
            Select Case m.Component.Type
                ' fixme: replace with IsForm() function?
                Case vbext_ct_MSForm, vbext_ct_VBForm, vbext_ct_VBMDIForm, vbext_ct_UserControl, vbext_ct_PropPage ', vbext_ct_ActiveXDesigner
                    Print #1,
                    Print #1, "extern _i_"; m.Name; " * _v_"; m.Name; "_"; m.Name; ";" ' This is kludged
            End Select
            EmitConstEnumType m, PROC_ATTR_PUBLIC
            Print #1,
            Print #1, "#undef INTERFACE"
'            Print #1, "#define INTERFACE "; m.Name
'            Print #1,
            Print #1, "DECLARE_INTERFACE_( __i_"; m.Name; ", IDispatch )"
            Print #1, "{"
            Print #1, indent; "INTERFACE_PROLOGUE_( __i_"; m.Name; ", IDispatch )"
            Print #1, "#undef INTERFACE"
            Print #1, "#define INTERFACE IUnknown"
            Print #1, indent; "STDMETHODEX( _m_QueryInterface, ( THIS_ REFIID _p_riid, LPVOID * _p_ppvObj ) )"
            Print #1, indent; "STDMETHODEX_( ULONG, _m_AddRef, ( THIS ) )"
            Print #1, indent; "STDMETHODEX_( ULONG, _m_Release, ( THIS ) )"
            Print #1, "#undef INTERFACE"
            Print #1, "#define INTERFACE IDispatch"
            Print #1, indent; "STDMETHODEX( _m_GetTypeInfoCount, ( THIS_ UINT *_p_pctinfo ) )"
            Print #1, indent; "STDMETHODEX( _m_GetTypeInfo, ( THIS_ UINT _p_iTInfo, LCID _p_lcid, ITypeInfo **_p_ppTInfo ) )"
            Print #1, indent; "STDMETHODEX( _m_GetIDsOfNames, ( THIS_ REFIID _p_riid, LPOLESTR *_p_rgszNames, UINT _p_cNames, LCID _p_lcid, DISPID *_p_rgDispID ) )"
            Print #1, indent; "STDMETHODEX( _m_Invoke, ( THIS_ DISPID _p_ispIdMember, REFIID _p_riid, LCID _p_lcid, WORD _p_wFlags, DISPPARAMS *_p_pDispParams, VARIANT *_p_pVarResult, EXCEPINFO *_p_pExcepInfo, UINT *_p_puArgErr ) )"
            Print #1, "#undef INTERFACE"
            Print #1, "#define INTERFACE __i_"; m.Name
            For Each proc In m.procs
                first_time = True
                s = "" ' Needed in case proc.procParams.count = 0
                For Each param In proc.procParams
                    If first_time Then first_time = False: s = "_ " Else s = s & ", "
                    s = s & cTypeName(param.paramVariable) & " _p_" & param.paramVariable.varSymbol
                Next
                Select Case proc.MemberType
                    Case vbext_mt_Method, vbext_mt_Property
                        Print #1, indent; "STDMETHODEX( _m_"; ProcNameIK(proc.procname, proc.InvokeKind); ", ( THIS"; s;
Print #99, "n="; proc.procname; " ik="; proc.InvokeKind
                        If (proc.MemberType = vbext_mt_Method And Not proc.procFunctionResultType Is Nothing) Or (proc.InvokeKind = INVOKE_PROPERTYGET) Then Print #1, ", "; cTypeName(proc.procFunctionResultType); " * _p_retval";
                        Print #1, " ) )"
                    Case vbext_mt_Variable
                        Print #1, indent; "STDMETHODEX( _m_"; ProcNameIK(proc.procname, INVOKE_PROPERTYGET); ", ( THIS"; s;
                        Print #1, ", "; cTypeName(proc.procFunctionResultType); " * _p_retval ) )"
                        If IsObj(proc.procFunctionResultType.VarType.dtDataType) Then
                            Print #1, indent; "STDMETHODEX( _m_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUTREF); ", ( THIS"; s;
                            Print #1, ", "; cTypeName(proc.procFunctionResultType); " _p_putval ) )"
                        Else
                            Print #1, indent; "STDMETHODEX( _m_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUT); ", ( THIS"; s;
                            Print #1, ", "; cTypeName(proc.procFunctionResultType); " _p_putval ) )"
                            If proc.procFunctionResultType.VarType.dtDataType = vbVariant Then
                                Print #1, indent; "STDMETHODEX( _m_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUTREF); ", ( THIS"; s;
                                Print #1, ", "; cTypeName(proc.procFunctionResultType); " _p_putval ) )"
                            End If
                        End If
                    Case Else ' vbext_mt_Const, vbext_mt_Event, vbext_mt_Property
                        Print #99, "cemitter: 1 Unimplemented Type:" & proc.MemberType
                        MsgBox "cemitter: Unimplemented Type:" & proc.MemberType
'                        Err.Raise 1
                End Select
            Next
            Print #1, indent; "INTERFACE_EPILOGUE_( __i_"; m.Name; ", IDispatch )"
            Print #1, "};"
            Print #1,
            Print #1, "_i_"; m.Name; " **_i_"; m.Name; "SA(SAFEARRAY *sa,int nDims,...);"
            ' fixme: create WithValue and QI protos?
            Print #1, "extern const ClassTable " & m.Name & "_ClassTable;"
            Print #1,
            For Each proc In m.procs
                Print #1, "#define "; m.Name & "_" & ProcNameIK(proc.procname, proc.InvokeKind) & "_( "; uniq; "This";
                For Each param In proc.procParams
                    Print #1, ", _p_"; param.paramVariable.varSymbol;
                Next
                Print #1, " ) ("; uniq; "This)->lpVtbl->_m_" & ProcNameIK(proc.procname, proc.InvokeKind) & "(ADJUST_THIS( _i_"; m.Name; ", "; uniq; "This, _m_"; ProcNameIK(proc.procname, proc.InvokeKind); " )";
                For Each param In proc.procParams
                    Print #1, ", _p_"; param.paramVariable.varSymbol;
                Next
                If Not proc.procFunctionResultType Is Nothing Then Print #1, ", _p_retval";
                Print #1, " )"
            Next
            Print #1,
            For Each proc In m.procs
                Select Case proc.MemberType
                    Case vbext_mt_Method
                        Print #1, "static HRESULT STDMETHODCALLTYPE "; m.Name; "_"; ProcNameIK(proc.procname, proc.InvokeKind); "( _i_"; m.Name; " * "; uniq; "This";
                        For Each param In proc.procParams
                            Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                        Next
                        If Not proc.procFunctionResultType Is Nothing Then Print #1, ", "; cTypeName(proc.procFunctionResultType); " * _p_retval";
                        Print #1, " );"
                    Case vbext_mt_Property
                        Print #1, "static HRESULT STDMETHODCALLTYPE "; m.Name; "_"; ProcNameIK(proc.procname, proc.InvokeKind); "( _i_"; m.Name; " * "; uniq; "This";
                        For Each param In proc.procParams
                            Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                        Next
                        Select Case proc.InvokeKind
                            Case INVOKE_PROPERTYGET
                                Print #1, ", "; cTypeName(proc.procFunctionResultType); " * _p_retval );"
'                            Case INVOKE_PROPERTYPUT, INVOKE_PROPERTYPUTREF
'                                Print #1, ", "; cTypeName(proc.procFunctionResultType); " _p_putval );"
                            Case Else
                                Print #1, " );" ' this isn't right - Command1
                        End Select
                    Case vbext_mt_Variable
                        Print #1, "static HRESULT STDMETHODCALLTYPE "; m.Name; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYGET); "( _i_"; m.Name; " * "; uniq; "This";
                        For Each param In proc.procParams
                            Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                        Next
                        Print #1, ", "; cTypeName(proc.procFunctionResultType); " * _p_retval );"
                        If IsObj(proc.procFunctionResultType.VarType.dtDataType) Then
                            Print #1, "static HRESULT STDMETHODCALLTYPE "; m.Name; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUTREF); "( _i_"; m.Name; " * "; uniq; "This";
                            For Each param In proc.procParams
                                Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                            Next
                            Print #1, ", "; cTypeName(proc.procFunctionResultType); " _p_putval );"
                        Else
                            Print #1, "static HRESULT STDMETHODCALLTYPE "; m.Name; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUT); "( _i_"; m.Name; " * "; uniq; "This";
                            For Each param In proc.procParams
                                Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                            Next
                            Print #1, ", "; cTypeName(proc.procFunctionResultType); " _p_putval );"
                            If proc.procFunctionResultType.VarType.dtDataType = vbVariant Then
                                Print #1, "static HRESULT STDMETHODCALLTYPE "; m.Name; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUTREF); "( _i_"; m.Name; " * "; uniq; "This";
                                For Each param In proc.procParams
                                    Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                                Next
                                Print #1, ", "; cTypeName(proc.procFunctionResultType); " _p_putval );"
                            End If
                        End If
                    Case Else ' vbext_mt_Const, vbext_mt_Event, vbext_mt_Property
                        Print #99, "cemitter: 2 Unimplemented Type:" & proc.MemberType
                        MsgBox "cemitter: Unimplemented Type:" & proc.MemberType
                        Err.Raise 1
                End Select
            Next
            ' Output non-automation prototype for global access
            Print #1,
            For Each proc In m.procs
Print #99, "proc.a n="; proc.procname; " mt="; proc.MemberType; " ik="; proc.InvokeKind
                s = ""
                For Each param In proc.procParams
                    s = s & ", " & cTypeName(param.paramVariable) & " _p_" & param.paramVariable.varSymbol
                Next
                Select Case proc.MemberType
                    Case vbext_mt_Method, vbext_mt_Property
                        Print #1, cTypeName(proc.procFunctionResultType); " STDMETHODCALLTYPE ___"; m.Name; "_"; ProcNameIK(proc.procname, proc.InvokeKind); "( _i_"; m.Name; " * "; uniq; "This"; s; " );"
                    Case vbext_mt_Variable
                        ' for control arrays
                        If proc.procFunctionResultType.varAttributes And VARIABLE_CONTROLARRAY Then Print #1, "IDispatch * STDMETHODCALLTYPE ___"; m.Name; "_"; ProcNameIK(proc.procname, INVOKE_FUNC); "( _i_"; m.Name; " * "; uniq; "This );"
                        Print #1, cTypeName(proc.procFunctionResultType); " STDMETHODCALLTYPE ___"; m.Name; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYGET); "( _i_"; m.Name; " * "; uniq; "This"; s; " );"
                        If IsObj(proc.procFunctionResultType.VarType.dtDataType) Then
                            Print #1, "void STDMETHODCALLTYPE ___"; m.Name; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUTREF); "( _i_"; m.Name; " * "; uniq; "This"; s; " ,"; cTypeName(proc.procFunctionResultType); " _p_putval);"
                        Else
                            Print #1, "void STDMETHODCALLTYPE ___"; m.Name; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUT); "( _i_"; m.Name; " * "; uniq; "This"; s; " ,"; cTypeName(proc.procFunctionResultType); " _p_putval);"
                            If proc.procFunctionResultType.VarType.dtDataType = vbVariant Then Print #1, "void STDMETHODCALLTYPE ___"; m.Name; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUTREF); "( _i_"; m.Name; " * "; uniq; "This"; s; " ,"; cTypeName(proc.procFunctionResultType); " _p_putval);"
                        End If
                    Case Else ' vbext_mt_Const, vbext_mt_Event
                        Print #99, "cemitter: 3 Unimplemented Type:" & proc.MemberType
                        MsgBox "cemitter: Unimplemented Type:" & proc.MemberType
                        Err.Raise 1
                End Select
            Next
            If m.Events.Count > 0 Then
                Print #1,
                Print #1, "#undef INTERFACE"
    '            Print #1, "#define INTERFACE "; m.Name
    '            Print #1,
                Print #1, "DECLARE_INTERFACE_( __i_"; m.EventName; ", IDispatch )"
                Print #1, "{"
                Print #1, indent; "INTERFACE_PROLOGUE_( __i_"; m.EventName; ", IDispatch )"
                Print #1, "#undef INTERFACE"
                Print #1, "#define INTERFACE IUnknown"
                Print #1, indent; "STDMETHODEX( _m_QueryInterface, ( THIS_ REFIID _p_riid, LPVOID * _p_ppvObj ) )"
                Print #1, indent; "STDMETHODEX_( ULONG, _m_AddRef, ( THIS ) )"
                Print #1, indent; "STDMETHODEX_( ULONG, _m_Release, ( THIS ) )"
                Print #1, "#undef INTERFACE"
                Print #1, "#define INTERFACE IDispatch"
                Print #1, indent; "STDMETHODEX( _m_GetTypeInfoCount, ( THIS_ UINT *_p_pctinfo ) )"
                Print #1, indent; "STDMETHODEX( _m_GetTypeInfo, ( THIS_ UINT _p_iTInfo, LCID _p_lcid, ITypeInfo **_p_ppTInfo ) )"
                Print #1, indent; "STDMETHODEX( _m_GetIDsOfNames, ( THIS_ REFIID _p_riid, LPOLESTR *_p_rgszNames, UINT _p_cNames, LCID _p_lcid, DISPID *_p_rgDispID ) )"
                Print #1, indent; "STDMETHODEX( _m_Invoke, ( THIS_ DISPID _p_dispIdMember, REFIID _p_riid, LCID _p_lcid, WORD _p_wFlags, DISPPARAMS *_p_pDispParams, VARIANT *_p_pVarResult, EXCEPINFO *_p_pExcepInfo, UINT *_p_puArgErr ) )"
                Print #1, "#undef INTERFACE"
                Print #1, "#define INTERFACE __i_"; m.EventName
                For Each proc In m.Events
                    Print #1, indent; "STDMETHODEX( _m_"; ProcNameIK(proc.procname, proc.InvokeKind); ", ( THIS";
                    first_time = True
                    For Each param In proc.procParams
                        If first_time Then first_time = False: Print #1, "_ "; Else Print #1, ", ";
                        Print #1, cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                    Next
                    If Not proc.procFunctionResultType Is Nothing Then Err.Raise 1 ' Event can't return a value
                    Print #1, " ) )"
                Next
                Print #1, indent; "INTERFACE_EPILOGUE_( __i_"; m.EventName; ", IDispatch )"
                Print #1, "};"
                Print #1,
                For Each proc In m.Events
                    Print #1, "#define "; m.EventName & "_" & ProcNameIK(proc.procname, proc.InvokeKind) & "_( "; uniq; "This";
                    For Each param In proc.procParams
                        Print #1, ", _p_"; param.paramVariable.varSymbol;
                    Next
                    Print #1, " ) ("; uniq; "This)->lpVtbl->_m_" & ProcNameIK(proc.procname, proc.InvokeKind) & "(ADJUST_THIS( _i_"; m.EventName; ", "; uniq; "This, _m_"; ProcNameIK(proc.procname, proc.InvokeKind); " )";
                    For Each param In proc.procParams
                        Print #1, ", _p_"; param.paramVariable.varSymbol;
                    Next
                    Print #1, " )"
                Next
                Print #1,
                For Each proc In m.Events
                    Print #1, "static HRESULT STDMETHODCALLTYPE "; m.EventName; "_"; ProcNameIK(proc.procname, proc.InvokeKind); "( _i_"; m.EventName; " * "; uniq; "This";
                    For Each param In proc.procParams
                        Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                    Next
                    Print #1, " );"
                Next
                Print #1,
                For Each proc In m.Events
                    Print #1, "void STDMETHODCALLTYPE ___"; m.EventName; "_"; ProcNameIK(proc.procname, proc.InvokeKind); "( _i_"; m.EventName; " * "; uniq; "This";
                    For Each param In proc.procParams
                        Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                    Next
                    Print #1, " );"
                Next
            End If
'            EmitConstEnumType m, PROC_ATTR_PUBLIC
            Close #1
            
' Output Class .c file
            group.AddIn.ProgressBarInit "C Generator: Creating " & OutputPath & m.Name & ".c"
            Open OutputPath & m.Name & ".c" For Output As 1
            Print #1, "/* This file is always generated by Softworks VBT */"
            Print #1,
            Print #1, "#include """; p.prjName; ".h"""
'            Print #1, "#include """; m.Name & ".h"""
            Print #1,
            Print #1, define_guid("IID", m.Name, m.interfaceGUID)
            Print #1, define_guid("CLSID", m.Name, m.GUID)
            Print #1,
'            If m.ModuleVars.Count > 0 Then Err.Raise 1 ' internal error
            Select Case m.Component.Type
                ' fixme: replace with IsForm() function?
                Case vbext_ct_MSForm, vbext_ct_VBForm, vbext_ct_VBMDIForm, vbext_ct_UserControl, vbext_ct_PropPage ', vbext_ct_ActiveXDesigner
                    Print #1, "_i_"; m.Name; " * _v_"; m.Name; "_"; m.Name; ";" ' This is kludged
            End Select
            If m.Events.Count > 0 Then Print #1, define_guid("IID", m.EventName, m.EventGUID)
            EmitConstEnumType m, PROC_ATTR_PRIVATE
Print #99, "a"
            If p.TypeLib Is Nothing Then s = "NoTypeLib" Else s = p.TypeLib.Name
            OutputClassMethods m, m.procs, m.Name
Print #99, "b"
            OutputClassMethods m, m.Events, m.EventName
Print #99, "c"
#If 0 Then
            Dim classes As Collection
            classes.Add m.procs
            If m.Events.procs.Count > 0 Then classes.Add m.Events
#End If
            Print #1,
        ' must fixup this - make collection of classes (procs and events?)!!
            If m.procs.Count > 0 And m.Events.Count > 0 Then
                Print #1, "static const InterfaceDescTable * const " & m.Name & "_InterfaceDescs[" & 2 & "] ="
                Print #1, "{"
                Print #1, indent; "&" & m.Name & "_InterfaceDesc,"
                Print #1, indent; "&" & m.EventName & "_InterfaceDesc"
                Print #1, "};"
                Print #1,
                Print #1, "static const UINT " & m.Name & "_InterfaceCount = 2;"
            ElseIf m.procs.Count > 0 Or m.Events.Count > 0 Then
                Print #1, "static const InterfaceDescTable * const " & m.Name & "_InterfaceDescs[" & 1 & "] ="
                Print #1, "{"
                Print #1, indent; "&" & IIf(m.procs.Count > 0, m.Name, m.EventName) & "_InterfaceDesc"
                Print #1, "};"
                Print #1,
                Print #1, "static const UINT " & m.Name & "_InterfaceCount = 1;"
            Else
                Print #1, "static const UINT " & m.Name & "_InterfaceCount = 0;"
            End If
' should ClassTable be omitted if procs? Thus assuming no classes or interfaces exist.
'    Could have only Enums, Consts or Types
            If m.procs.Count > 0 Or m.Events.Count > 0 Then
                Print #1,
                Print #1, "const ClassTable "; m.Name; "_ClassTable ="
                Print #1, "{"
                Print #1, indent; "L"""; m.Name; """, /* Name */"
                Print #1, indent; "&CLSID_"; m.Name; ", /* GUID */"
                Print #1, indent; "L"""; p.prjName; "."; m.Name; ".1"", /* ProgID */"
                Print #1, indent; "L"""; p.prjName; "."; m.Name; """, /* VIProgID */"
                Print #1, indent; "&"; m.Name; "_InterfaceCount, /* InterfaceCount */"
                Print #1, indent; m.Name; "_InterfaceDescs, /* InterfaceDescs */"
                Print #1, "};"
            End If
            Close #1
        End Select
    Next ' p.prjModules
Next ' group.project
Print #99, "Emiter: done"

End Sub

Sub OutputClassMethods(ByVal m As vbModule, ByVal procs As Collection, ByVal interfacename As String)
Dim proc As procTable
Dim param As paramTable
Dim first_time As Boolean
Dim i As Integer

Print #99, "ocm: 1"
If procs.Count > 0 Then ' why does next statement make 1 loop if procs.count = 0?
Print #99, "ocm: 2"
    For Each proc In procs
Print #99, "ocm: 3"
        Dim procNumber As Long
        procNumber = procNumber + 1
        If proc.procParams.Count > 0 Then
Print #99, "ocm: 4"
            Print #1,
            Print #1, "static TYPEDESC " & interfacename & "_" & ProcNameIK(proc.procname, proc.InvokeKind) & "_TypeDescs[" & proc.procParams.Count & "] ="
            Print #1, "{"
            i = 0
            Dim vt As String
            first_time = True
            For Each param In proc.procParams
                If first_time Then first_time = False Else Print #1, ","
                If param.paramVariable.varAttributes And VT_BYREF Then vt = VT_Type(param.paramVariable) Else vt = "0"
                Print #1, indent; "{ NULL, "; vt; " }";
                i = i + 1
            Next
            Print #1,
            Print #1, "};"
            Print #1,
            Print #1, "static ELEMDESC " & interfacename & "_" & ProcNameIK(proc.procname, proc.InvokeKind) & "_ElemDescs[" & proc.procParams.Count & "] ="
            Print #1, "{"
            Dim IDLFlags As String
            i = 0
            first_time = True
            For Each param In proc.procParams
                If first_time Then first_time = False Else Print #1, ","
                If param.paramVariable.varSymbol = "_retval" Then IDLFlags = "IDLFLAG_FOUT | IDLFLAG_FRETVAL" Else If param.paramVariable.varAttributes And VT_BYREF Then IDLFlags = "IDLFLAG_FIN | IDLFLAG_FOUT" Else IDLFlags = "IDLFLAG_FIN"
                Print #1, indent; "{ { &"; interfacename & "_" & ProcNameIK(proc.procname, proc.InvokeKind) & "_TypeDescs["; i; "], "; VT_Type(param.paramVariable); " }, { 0, "; IDLFlags; " } }";
                i = i + 1
            Next
            Print #1,
            Print #1, "};"
        End If
        Print #1,
' remove this table and generate code in FuncNames (below)
        Print #1, "static const FUNCDESC " & interfacename & "_" & ProcNameIK(proc.procname, proc.InvokeKind) & "_FuncDesc ="
        Print #1, "{"
' fixme: kludge to detect interface vs event
        If Left(interfacename, 2) = "__" Then ' event dispinterface
            Print #1, indent; "0x0000"; Right("0000" & Hex(procNumber), 4); ", NULL, "; IIf(proc.procParams.Count = 0, "NULL", interfacename & "_" & ProcNameIK(proc.procname, proc.InvokeKind) & "_ElemDescs"); ", FUNC_DISPATCH, INVOKE_FUNC, CC_CDECL, "; CStr(proc.procParams.Count); ", 0, 0, 0, { { NULL, VT_HRESULT }, { 0, IDLFLAG_FOUT } }, 0"
        Else ' interface
            Print #1, indent; "0x6003"; Right("0000" & Hex(procNumber), 4); ", NULL, "; IIf(proc.procParams.Count = 0, "NULL", interfacename & "_" & ProcNameIK(proc.procname, proc.InvokeKind) & "_ElemDescs"); ", FUNC_PUREVIRTUAL, INVOKE_FUNC, CC_CDECL, "; CStr(proc.procParams.Count); ", 0, 0, 0, { { NULL, VT_HRESULT }, { 0, IDLFLAG_FOUT } }, 0"
        End If
        Print #1, "};"
        Print #1,
        Print #1, "static const LPCOLESTR " & interfacename & "_" & ProcNameIK(proc.procname, proc.InvokeKind) & "_FuncNames[" & proc.procParams.Count + 1 & "] ="
        Print #1, "{"
        Print #1, indent; "L"""; ProcNameIK(proc.procname, proc.InvokeKind); """";
' Need to output RetVal for functions
        For Each param In proc.procParams
            Print #1, ", L"""; param.paramVariable.varSymbol; """";
        Next
        Print #1,
        Print #1, "};"
    Next
Print #99, "ocm: 5"
    Print #1,
    Print #1, "static FuncTable " & interfacename & "_Funcs[" & procs.Count & "] ="
    Print #1, "{"
    first_time = True
    For Each proc In procs
        If first_time Then first_time = False Else Print #1, ","
        Print #1, indent; "{ &" & interfacename; "_"; ProcNameIK(proc.procname, proc.InvokeKind); "_FuncDesc, "; interfacename; "_"; ProcNameIK(proc.procname, proc.InvokeKind); "_FuncNames }";
    Next
    Print #1,
    Print #1, "};"
    Print #1,
    Print #1, "static const __i_" & interfacename; "Vtbl _i_"; interfacename; "VtblInstance ="
    Print #1, "BEGIN_VTABLE"
    Print #1, indent; "VTABLE_ENTRY( Generic_IUnknown_QueryInterface ),"
    Print #1, indent; "VTABLE_ENTRY( Generic_IUnknown_AddRef ),"
    Print #1, indent; "VTABLE_ENTRY( Generic_IUnknown_Release ),"
    Print #1, indent; "VTABLE_ENTRY( Generic_IDispatch_GetTypeInfoCount ),"
    Print #1, indent; "VTABLE_ENTRY( Generic_IDispatch_GetTypeInfo ),"
    Print #1, indent; "VTABLE_ENTRY( Generic_IDispatch_GetIDsOfNames ),"
    Print #1, indent; "VTABLE_ENTRY( Generic_IDispatch_Invoke )";
    For Each proc In procs
        Print #1, "," ' don't output , on last item
        Select Case proc.MemberType
            Case vbext_mt_Event, vbext_mt_Method, vbext_mt_Property
                Print #1, indent; "VTABLE_ENTRY( "; interfacename; "_"; ProcNameIK(proc.procname, proc.InvokeKind); " )";
            Case vbext_mt_Variable
                Print #1, indent; "VTABLE_ENTRY( "; interfacename; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYGET); " ),"
                If IsObj(proc.procFunctionResultType.VarType.dtDataType) Then
                    Print #1, indent; "VTABLE_ENTRY( "; interfacename; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUTREF); " )";
                Else
                    Print #1, indent; "VTABLE_ENTRY( "; interfacename; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUT); " )";
                    If proc.procFunctionResultType.VarType.dtDataType = vbVariant Then Print #1, ","; vbCrLf; indent; "VTABLE_ENTRY( "; interfacename; "_"; ProcNameIK(proc.procname, INVOKE_PROPERTYPUTREF); " )";
                End If
            Case Else ' vbext_mt_Const, vbext_mt_Event, vbext_mt_Property
                Print #99, "OutputClassMethods: Unimplemented Type:" & proc.MemberType
                MsgBox "OutputClassMethods: Unimplemented Type:" & proc.MemberType
                Err.Raise 1
        End Select
    Next
    Print #1, ' need NL here
    Print #1, "END_VTABLE;"
Print #99, "d"
    OutputMethods m, procs, interfacename
Print #99, "e"
    Print #1,
    Print #1, "static const InterfaceDescTable " & interfacename & "_InterfaceDesc ="
    Print #1, "{"
    Print #1, indent & "{ (IUnknownVtbl *)&_i_" & interfacename & "VtblInstance }, 0, NULL, NULL, L""_"; interfacename & """, &IID_" & interfacename & ", " & procs.Count & " , " & interfacename & "_Funcs"
    Print #1, "};"
End If

End Sub

Sub OutputMethods(ByVal m As vbModule, ByVal procs As Collection, ByVal interfacename As String)
Dim proc As procTable
Dim param As paramTable
Dim first_time As Boolean
Dim procname As String
Dim interfaceProcName
Dim ik As InvokeKinds
Dim s As String

Print #99, "OutputMethods: m="; m.Name
For Each proc In procs
Print #99, "proc: n="; proc.procname; " at="; Hex(proc.procattributes)
    If proc.procattributes And PROC_ATTR_VARIABLE Then
        Print #99, "dt="; proc.procFunctionResultType.VarType.dtDataType
        ik = INVOKE_PROPERTYGET
        GoSub 10
        If IsVObj(proc.procFunctionResultType.VarType.dtDataType) Then
            ik = INVOKE_PROPERTYPUTREF
            GoSub 10
        End If
        If Not IsObj(proc.procFunctionResultType.VarType.dtDataType) Then
            ik = INVOKE_PROPERTYPUT
            GoSub 10
        End If
    Else
        ik = proc.InvokeKind
        GoSub 10
Print #99, "3"
    End If
Next
Print #99, "3a"
Exit Sub

10 ' GoSub label
Print #99, "4"
    procname = ProcNameIK(proc.procname, ik)
    interfaceProcName = interfacename & "_" & procname
    Dim lvCount As Integer
    If m.Component.Type = vbext_ct_StdModule Then lvCount = 0 Else lvCount = 1 ' hr
    If proc.MemberType <> vbext_mt_Variable And Not proc.procFunctionResultType Is Nothing Then lvCount = lvCount + 1 ' function name
    lvCount = lvCount + proc.procLocalVariables.Count
Print #99, "5 n="; interfaceProcName; " lv="; lvCount
    If lvCount = 0 Then GoSub 30 Else GoSub 20
Print #99, "6"
    Return
20
Print #99, "7"
    Print #1,
    Print #1, "struct "; interfaceProcName; "_localvars"
    Print #1, "{"
    If m.Component.Type = vbext_ct_StdModule Then
        If proc.MemberType <> vbext_mt_Variable And Not proc.procFunctionResultType Is Nothing Then Print #1, indent; cTypeName(proc.procFunctionResultType); " _v_" & proc.procFunctionResultType.varSymbol & ";"
    Else
        Print #1, indent; "HRESULT hr;"
    End If
    Dim v As vbVariable
    For Each v In proc.procLocalVariables
        Print #1, indent; VarDeclaration(v, True)
    Next
    Print #1, "};"
#If 0 Then
    If proc.procLiteralPool.Count > 0 Then
        ' attempt at string literal declarations. problems with [] defs.
        Print #1,
        Dim lp As Variant
        first_time = True
        For Each lp In proc.procLiteralPool
            Print #1, "static const struct literalpool_t lp"; CStr(nlp); " = {"; Len(lp) + 1; "* sizeof(wchar_t), ";
            nlp = nlp + 1
            Dim i As Integer
            For i = 1 To Len(lp)
                If first_time Then first_time = False Else Print #1, ", ";
                Print #1, "L'"; Mid(lp, i, 1); "'";
            Next
            Print #1, "};"
        Next
#If 0 Then
        ' attempt at string literal pooling into one struct. problems with BSTR length
        Print #1,
        Print #1, "#undef LP"
        Print #1, "#define LP(i) "; interfaceProcName; "_literalpool_descriptor[i].lp_str"
        Print #1, "static const struct literalpool_t "; interfaceProcName; "_literalpool_descriptor["; proc.procLiteralPool.Count; "] = "
        Print #1, "{"
        Dim lp As Variant
        first_time = True
        For Each lp In proc.procLiteralPool
            If first_time Then first_time = False Else Print #1, ","
            Print #1, indent; "{"; Len(lp) + 1; "* sizeof(wchar_t), L"""; lp; """}";
        Next
        Print #1,
        Print #1, "};"
#End If
    End If
#End If
    Print #1,
    Print #1, "static const struct localvars_t "; interfaceProcName; "_localvars_descriptor["; lvCount; "] = "
    Print #1, "{"
    first_time = True
    If m.Component.Type = vbext_ct_StdModule Then
        If proc.MemberType <> vbext_mt_Variable And Not proc.procFunctionResultType Is Nothing Then
            Print #1, indent; "{ offsetof(struct " & interfaceProcName & "_localvars, _v_" & proc.procFunctionResultType.varSymbol & "), L""" & proc.procFunctionResultType.varSymbol & """, " & proc.procFunctionResultType.VarType.dtDataType & ", NULL }";
            first_time = False
        End If
    Else
        If first_time Then first_time = False Else Print #1, ","
        Print #1, indent; "{ offsetof(struct " & interfaceProcName & "_localvars, hr ), L""hr"", " & VT_HRESULT & ", NULL }";
    End If
    For Each v In proc.procLocalVariables
' Need to translate dtdatatype into VT_xxx
        If first_time Then first_time = False Else Print #1, ","
' fixme: SAFEARRAY init stuff goes here!?
#If 0 Then
'                Print #1, ","
        s = ""
        If Not v.varDimensions Is Nothing Then
            s = s & "{ "
            For Each p In v.varDimensions
                s = s & p.varDimensionLBound & ", " & p.varDimensionUBound - p.varDimensionLBound + 1
            Next
            s = s & " }"
        End If
' Need to do something with String *?
'        If v.VarType.dtDataType = VT_BSTR And v.VarType.dtLength <> 0 Then s = s & "[" & v.VarType.dtLength & "]"
#End If
        Print #1, indent; "{ offsetof(struct " & interfaceProcName & "_localvars, _v_" & v.varSymbol & "), L""" & v.varSymbol & """, " & v.VarType.dtDataType & ", NULL}";
    Next
    Print #1,
    Print #1, "};"
30
Print #1,
Print #1, "static const struct methodinfo_t "; interfaceProcName; "_methodinfo ="
Print #1, "{"
Print #1, indent; IIf(m.Component.Type = vbext_ct_StdModule, "NULL", "L""" & interfacename & """") & ", L""" & interfaceProcName & ""","
If lvCount = 0 Then
    Print #1, indent; "NULL, 0, 0"
Else
    Print #1, indent; interfaceProcName & "_localvars_descriptor, "; lvCount; ", sizeof(struct "; interfaceProcName & "_localvars)"
End If
Print #1, "};"
Print #1,
    Select Case m.Component.Type
        Case vbext_ct_StdModule
    ' if Private then output static
            Print #1, cTypeName(proc.procFunctionResultType); " STDMETHODCALLTYPE "; interfaceProcName; "( ";
            first_time = True
            For Each param In proc.procParams
                If first_time Then first_time = False Else Print #1, ", ";
                Print #1, cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
            Next
'            If first_time Then Print #1, "void";
        Case vbext_ct_RelatedDocument
            Print #99, "OutputMethods: Unimplemented ComponentType:" & m.Component.Type
'            MsgBox "OutputMethods: Unknown ComponentType:" & m.component.type
'            Err.Raise 1
        Case Else
' fixme: same as code above
            Select Case proc.MemberType
                Case vbext_mt_Event, vbext_mt_Method
                    Print #1, "static HRESULT STDMETHODCALLTYPE "; interfaceProcName; "( _i_"; interfacename; " * "; uniq; "This";
                    For Each param In proc.procParams
                        Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                    Next
                    If Not proc.procFunctionResultType Is Nothing Then Print #1, ", "; cTypeName(proc.procFunctionResultType); " * _p_retval";
'                    Print #1, " );"
                Case vbext_mt_Property
                    Print #1, "static HRESULT STDMETHODCALLTYPE "; interfaceProcName; "( _i_"; interfacename; " * "; uniq; "This";
                    For Each param In proc.procParams
                        Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                    Next
                    Select Case proc.InvokeKind
                        Case INVOKE_PROPERTYGET
                            Print #1, ", "; cTypeName(proc.procFunctionResultType); " * _p_retval";
'                        Case INVOKE_PROPERTYPUT, INVOKE_PROPERTYPUTREF
'                            Print #1, ", "; cTypeName(proc.procFunctionResultType); proc.procFunctionResultType.varSymbol;
'                        Case Else
'                            Print #1, " );"
                    End Select
                Case vbext_mt_Variable
                    Print #1, "static HRESULT STDMETHODCALLTYPE "; interfaceProcName; "( _i_"; interfacename; " * "; uniq; "This";
                    For Each param In proc.procParams
                        Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                    Next
                    Select Case ik
                        Case INVOKE_PROPERTYGET
                            Print #1, ", "; cTypeName(proc.procFunctionResultType); " * _p_retval";
                        Case INVOKE_PROPERTYPUT, INVOKE_PROPERTYPUTREF
                            Print #1, ", "; cTypeName(proc.procFunctionResultType); " _p_putval";
'                        Case Else
'                            Print #1, " );"
                    End Select
                Case Else ' vbext_mt_Const, vbext_mt_Property
                    Print #99, "OutputMethods: Unimplemented Type:" & proc.MemberType
                    MsgBox "OutputMethods: Unimplemented Type:" & proc.MemberType
                    Err.Raise 1
            End Select
    End Select
    Print #1, " )"
    Print #1, "{"
'        If m.component.type = vbext_ct_stdModule And Not proc.procFunctionResultType Is Nothing Then Print #1, cTypeName(proc.procFunctionResultType); " " & proc.procFunctionResultType.varSymbol & ";"
    If lvCount = 0 Then
        Print #1, indent; "METHOD_INITIALIZE(&"; interfaceProcName; "_methodinfo, NULL)"
    Else
        Print #1, "struct "; interfaceProcName; "_localvars lv;"
        Print #1, indent; "METHOD_INITIALIZE(&"; interfaceProcName; "_methodinfo, &lv)"
    End If
    Print #99, "OutputMethods: n="; interfaceProcName; " mt="; proc.MemberType; " ct="; m.Component.Type; " ik="; ik
    Select Case proc.MemberType
        Case vbext_mt_Event, vbext_mt_Method, vbext_mt_Property
            Dim stmts As Collection
            For Each stmts In proc.procStatements
                m_Group.AddIn.ProgressBarUpdate LineCount / TotalLines
                Print #1, EmitInFix(proc, stmts)
                LineCount = LineCount + 1
            Next
        Case vbext_mt_Variable
            Select Case ik
                Case INVOKE_PROPERTYGET
                    Print #1, indent; "*_p_retval = _v_"; interfacename & "_" & ProcNameIK(proc.procname, proc.InvokeKind); ";"
                Case INVOKE_PROPERTYPUT, INVOKE_PROPERTYPUTREF
                    Print #1, indent; "_v_" & interfacename & "_" & ProcNameIK(proc.procname, proc.InvokeKind); " = _p_putval;"
                Case Else
                    Err.Raise 1 ' Internal error
            End Select
        Case Else
            Err.Raise 1 ' Internal error
    End Select
    If lvCount = 0 Then
        Print #1, indent; "METHOD_TERMINATE(&"; interfaceProcName; "_methodinfo, NULL)"
    Else
        Print #1, indent; "METHOD_TERMINATE(&"; interfaceProcName; "_methodinfo, &lv)"
    End If
    Select Case m.Component.Type
        Case vbext_ct_RelatedDocument
            Print #99, "OutputMethods: Unknown ComponentType:" & m.Component.Type
'            MsgBox "OutputMethods: Unknown ComponentType:" & m.component.type
'            Err.Raise 1
        Case vbext_ct_StdModule
            If Not proc.procFunctionResultType Is Nothing Then Print #1, indent; "return lv._v_" & proc.procFunctionResultType.varSymbol & ";"
            Print #1, "}"
        Case Else
            Print #1, indent; "return lv.hr;"
            Print #1, "}"
            Print #99, "proc.b n="; procname; " mt="; proc.MemberType
            Print #1,
            Select Case proc.MemberType
                Case vbext_mt_Event, vbext_mt_Method
                    Print #1, cTypeName(proc.procFunctionResultType); " STDMETHODCALLTYPE ___"; interfaceProcName; "( _i_"; interfacename; " * "; uniq; "This";
                    For Each param In proc.procParams
                        Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                    Next
' this is duped two times - fix it
                    s = ""
                    For Each param In proc.procParams
                        s = s & ", _p_" & param.paramVariable.varSymbol
                    Next
                    If Not proc.procFunctionResultType Is Nothing Then
                        Print #1, " ){"; cTypeName(proc.procFunctionResultType); " _v_retval"; ";ChkHR(This->lpVtbl->_m_"; procname; "(ADJUST_THIS("; interfaceProcName; ",This,_m_"; interfaceProcName; ")"; s; ",&_v_retval),L"""; procname; """);return _v_retval;}"
                    Else
                        Print #1, " ){ChkHR(This->lpVtbl->_m_"; procname; "(ADJUST_THIS("; interfaceProcName; ",This,_m_"; interfaceProcName; ")"; s; "),L"""; interfaceProcName; """);}"
                    End If
                Case vbext_mt_Property
                    Print #1, cTypeName(IIf(ik = INVOKE_PROPERTYPUT Or ik = INVOKE_PROPERTYPUTREF, Nothing, proc.procFunctionResultType)) & " STDMETHODCALLTYPE ___"; interfaceProcName; "( _i_"; interfacename; " * "; uniq; "This";
                    For Each param In proc.procParams
                        Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                    Next
' this is duped two times - fix it
                    s = ""
                    For Each param In proc.procParams
                        s = s & ", _p_" & param.paramVariable.varSymbol
                    Next
                    Select Case ik
                        Case 0, INVOKE_PROPERTYGET
                            Print #1, " ){"; cTypeName(proc.procFunctionResultType); " _v_retval"; ";ChkHR(This->lpVtbl->_m_"; procname; "(ADJUST_THIS("; interfaceProcName; ",This,_m_"; interfaceProcName; ")"; s; ",&_v_retval),L"""; procname; """);return _v_retval;}"
                        Case INVOKE_PROPERTYPUT, INVOKE_PROPERTYPUTREF
                            Print #1, " ){ChkHR(This->lpVtbl->_m_"; procname; "(ADJUST_THIS("; interfaceProcName; ",This,_m_"; interfaceProcName; ")"; s; "),L"""; interfaceProcName; """);}"
                        Case Else
                            Print #99, "cemitter: Unimplemented INVOKEKIND:" & ik
                            MsgBox "cemitter: Unimplemented INVOKEKIND:" & ik
                            Err.Raise 1
                    End Select
                Case vbext_mt_Variable
                    Print #1, cTypeName(IIf(ik = INVOKE_PROPERTYPUT Or ik = INVOKE_PROPERTYPUTREF, Nothing, proc.procFunctionResultType)) & " STDMETHODCALLTYPE ___"; interfaceProcName; "( _i_"; interfacename; " * "; uniq; "This";
                    For Each param In proc.procParams
                        Print #1, ", "; cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
                    Next
                    s = ""
                    For Each param In proc.procParams
                        s = s & ", _p_" & param.paramVariable.varSymbol
                    Next
                    Select Case ik
                        Case INVOKE_PROPERTYGET
                            Print #1, " ){"; cTypeName(proc.procFunctionResultType); " _v_retval"; ";ChkHR(This->lpVtbl->_m_"; procname; "(ADJUST_THIS("; interfaceProcName; ",This,_m_"; interfaceProcName; ")"; s; ",&_v_retval),L"""; procname; """);return _v_retval;}"
                        Case INVOKE_PROPERTYPUT, INVOKE_PROPERTYPUTREF
                            Print #1, ", "; cTypeName(proc.procFunctionResultType); " _p_putval){ChkHR(This->lpVtbl->_m_"; procname; "(ADJUST_THIS("; interfaceProcName; ",This,_m_"; interfaceProcName; ")"; s; ",_p_putval),L"""; interfaceProcName; """);}"
                        Case Else
                            Print #99, "cemitter: Unimplemented INVOKEKIND:" & ik
                            MsgBox "cemitter: Unimplemented INVOKEKIND:" & ik
                            Err.Raise 1
                    End Select
                Case Else ' vbext_mt_Const, vbext_mt_Event, vbext_mt_Property
                    Print #99, "OutputMethods: 2 Unimplemented Type:" & proc.MemberType
                    MsgBox "OutputMethods: Unimplemented Type:" & proc.MemberType
                    Err.Raise 1
        End Select
    End Select
Return
End Sub

Sub EmitDeclare(ByVal d As vbDeclare, ByVal scope As procattributes)
Dim first_time As Boolean
    Print #1, IIf(scope And PROC_ATTR_PUBLIC, "Public", "Private"); " Declare ";
#If 0 Then
    If d.dclFunctionResultType Is Nothing Then
        Print #1, "void WINAPI ";
    Else
        Print #1, cTypeName(d.dclFunctionResultType) & " WINAPI ";
    End If
' d.dclLib in production of .BAT/.MAK file
    If d.dclAlias = "" Then Print #1, d.dclName; Else Print #1, d.dclAlias;
#Else
Print #99, "EmitDeclare: rt="; d.dclFunctionResultType Is Nothing
    If d.dclFunctionResultType Is Nothing Then
'        Print #1, "void";
'        Print #1, "Sub("; d.dclModule.Name; "_"; IIf(d.dclAlias = "", d.dclName, d.dclAlias); ",(";
        Print #1, "Sub("; d.dclModule.Name; "_"; d.dclName; ",(";

    Else
'        Print #1, cTypeName(d.dclFunctionResultType);
'        Print #1, "Function("; d.dclModule.Name; "_"; IIf(d.dclAlias = "", d.dclName, d.dclAlias); ","; cTypeName(d.dclFunctionResultType); ",(";
        Print #1, "Function("; d.dclModule.Name; "_"; d.dclName; ","; cTypeName(d.dclFunctionResultType); ",(";
    End If
#End If
'    Print #1, " _"; d.dclName; "( ";
    first_time = True
    Dim param As paramTable
    For Each param In d.dclParams
        If first_time Then first_time = False Else Print #1, ", ";
        Print #1, cTypeName(param.paramVariable); " _p_"; param.paramVariable.varSymbol;
    Next
    If first_time Then Print #1, "void";
'    Print #1, " );"
    Print #1, "))"
End Sub

Sub EmitConstEnumType(ByVal o As vbModule, ByVal scope As procattributes)
Dim v As vbVariable
Dim first_time As Boolean
first_time = True
' only need to do IIF scope once - assign to string
'If o.Consts.Count > 0 Then Print #1, vbCrLf; "/* Enum member references have been converted to constants - Enums are shown for display only */"
Dim c As vbConst
For Each c In o.Consts
    If CBool(scope And c.ConstAttributes) Or (CBool(scope And PROC_ATTR_PRIVATE) And Not CBool(c.ConstAttributes And PROC_ATTR_PUBLIC)) Then
        If first_time Then first_time = False: Print #1,
' add constant value - Print #1, "const " & cTypeName(v) & " " & v.varSymbol & ";"
        Print #99, "c="; c.ConstName; " c.dt="; c.ConstDataType.dtDataType
        Print #1, IIf(scope And PROC_ATTR_PUBLIC, "Public", "Private") & " Const(" & o.Name & "_" & c.ConstName & "," & VarTypeToC(c.ConstDataType.dtDataType) & "," & ValueToC(c.ConstDataType.dtDataType, c.ConstValue) & ")"
' removed casting - had problem with (VARIANT)(...)
'        Print #1, "#define _c_" & o.Name & "_" & c.ConstName & " (" & VarTypeToC(c.ConstDataType.dtDataType) & ")(" & EmitInFix(Nothing, c.ConstRPN) & ")"
'        Print #1, "#define _c_" & o.Name & "_" & c.ConstName & " (" & EmitInFix(Nothing, c.ConstRPN) & ") /* " & VarTypeToC(c.ConstDataType.dtDataType) & " */"
    End If
Next
Dim e As vbEnum
For Each e In o.Enums
    If CBool(scope And e.enumAttributes) Or (CBool(scope And PROC_ATTR_PUBLIC) And Not CBool(e.enumAttributes And PROC_ATTR_PRIVATE)) Then
        Print #1,
        Print #1, "/* enum " & e.enumName & " */"
'        Print #1, "{"
        Print #1, IIf(scope And PROC_ATTR_PUBLIC, "Public", "Private") & " Enum(" & o.Name & "_" & e.enumName & ")"
        Dim em As vbEnumMember
        Dim emval As Long
        emval = 0
        first_time = True
        For Each em In e.enumMembers
#If 0 Then
            Print #1, "#define _e_"; o.Name & "_" & e.enumName; "_"; em.enumMemberName;
''''if em.enumMemberRPN.Count = 0 ...            Print #1, " (" & EmitInFix(Nothing, em.enumMemberRPN) & ")"
#Else
            ' be sure to make # appear in column 1 for UNIX C compatibility.
            Print #1, "#define _e_"; o.Name & "_" & e.enumName; "_"; em.enumMemberName; " ("; ValueToC(vbLong, em.enumMemberValue) & ")"
'            If first_time Then first_time = False Else Print #1, ","
'            Print #1, " ("; em.enumMemberValue & ")"
'            If em.enumMemberValue <> emval Then
'                emval = em.enumMemberValue
'                Print #1, " = "; CStr(emval);
'            End If
'            print #1,
#End If
            emval = emval + 1
        Next
'        Print #1, "};"
        Print #1, "EndEnum(" & o.Name & "_" & e.enumName & ")"
    End If
Next
If o.types.Count > 0 Then Print #1,
Dim t As vbType
For Each t In o.types
' Problem: Private Types can be used to declare Public variables. Comment out, until solution found.
'    If CBool(scope And t.typeAttributes) Or (CBool(scope And PROC_ATTR_PUBLIC) And Not CBool(t.typeAttributes And PROC_ATTR_PRIVATE)) Then
    If scope And PROC_ATTR_PUBLIC Then ' always put in header
        Print #1,
'        Print #1, "typedef struct _" & t.TypeName & "_t"
'        Print #1, "{"
        Print #1, "Public Type(" & o.Name & "_" & t.TypeName & ")"
'        Print #1, "{"
        For Each v In t.typeMembers
            Print #1, indent; VarDeclaration(v, True)
        Next
'        Print #1, "} " & t.TypeName & ";"
        Print #1, "EndType(" & o.Name & "_" & t.TypeName & ")"
        ' fixme: use routine to output _t_ stuff
        Print #1, "typedef struct __t_"; o.Name & "_"; t.TypeName; " _t_"; o.Name & "_"; t.TypeName; ";"
        Print #1, "_t_"; o.Name; "_" & t.TypeName; " * _t_"; o.Name; "_" & t.TypeName; "SA(SAFEARRAY *sa,int nDims,...);"
    End If
Next
Dim d As vbDeclare
first_time = True
For Each d In o.Declares
    If CBool(scope And d.dclAttributes) Or (CBool(scope And PROC_ATTR_PUBLIC) And Not CBool(d.dclAttributes And PROC_ATTR_PRIVATE)) Then
        If first_time Then first_time = False: Print #1,
        EmitDeclare d, scope
    End If
Next
' make global vars a struct? Needs init to zero, perhaps in ClassInit!
If CBool(scope And PROC_ATTR_PUBLIC) Then
    ' .h
    For Each v In o.ModuleVars
Print #99, "EmitCET: "; o.Name & "_" & v.varSymbol; " a="; Hex(v.varAttributes)
        If v.varAttributes And PROC_ATTR_PUBLIC Then
            Print #1, "extern ";
            If o.Component.Type <> vbext_ct_StdModule Or Not CBool(v.varAttributes And PROC_ATTR_PUBLIC) Then Print #1, "static ";
            Print #1, VarDeclaration(v)
        End If
    Next
Else
    ' .c
    For Each v In o.ModuleVars
        If o.Component.Type <> vbext_ct_StdModule Or Not CBool(v.varAttributes And PROC_ATTR_PUBLIC) Then Print #1, "static ";
        Print #1, VarDeclaration(v)
    Next
    Dim proc As procTable
    For Each proc In o.procs
        If o.Component.Type <> vbext_ct_StdModule And proc.MemberType = vbext_mt_Variable Then
            Set v = proc.procFunctionResultType
'            If v.varDimensions Is Nothing Then
                Print #1, "static "; cTypeName(v); " _v_";
'            Else
'                Print #1, "static SAFEARRAY * ";
'                If v.varDimensions.Count = 0 Then Print #1, "*";
'            End If
            Print #1, o.Name & "_" & v.varSymbol; ";"
        End If
    Next
End If
End Sub
